"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License;
 * you may not use this file except in compliance with the Elastic License.
 */
const js_yaml_1 = tslib_1.__importDefault(require("js-yaml"));
const lodash_1 = require("lodash");
const lodash_2 = require("lodash");
const lodash_3 = tslib_1.__importDefault(require("lodash"));
class TagsLib {
    constructor(adapter, tagConfigs) {
        this.adapter = adapter;
        this.tagConfigs = tagConfigs;
    }
    async getTagsWithIds(tagIds) {
        return this.jsonConfigToUserYaml(await this.adapter.getTagsWithIds(tagIds));
    }
    async delete(tagIds) {
        return await this.adapter.delete(tagIds);
    }
    // FIXME: This needs to be paginated https://github.com/elastic/kibana/issues/26022
    async getAll(ESQuery) {
        return this.jsonConfigToUserYaml(await this.adapter.getAll(ESQuery));
    }
    async upsertTag(tag) {
        tag.id = tag.id.replace(' ', '-');
        return await this.adapter.upsertTag(this.userConfigsToJson([tag])[0]);
    }
    jsonConfigToUserYaml(tags) {
        return tags.map(tag => {
            const transformedTag = tag;
            // configuration_blocks yaml, JS cant read YAML so we parse it into JS,
            // because beats flattens all fields, and we need more structure.
            // we take tagConfigs, grab the config that applies here, render what we can into
            // an object, and the rest we assume to be the yaml string that goes
            // into the yaml editor...
            // NOTE: The perk of this, is that as we support more features via controls
            // vs yaml editing, it should "just work", and things that were in YAML
            // will now be in the UI forms...
            transformedTag.configuration_blocks = (tag.configuration_blocks || []).map(block => {
                const { type, description, configs } = block;
                const activeConfig = configs[0];
                const thisConfig = this.tagConfigs.find((conf) => conf.value === type).config;
                const knownConfigIds = thisConfig.map((config) => config.id);
                const hydratedIds = this.hydrateTokenArray(knownConfigIds, activeConfig);
                const convertedConfig = knownConfigIds.reduce((blockObj, id, index) => {
                    const unhydratedKey = hydratedIds[index];
                    lodash_2.set(blockObj, id, id === 'other'
                        ? js_yaml_1.default.dump(lodash_2.omit(activeConfig, knownConfigIds))
                        : lodash_1.get(activeConfig, unhydratedKey));
                    return blockObj;
                }, {});
                // Workaround to empty object passed into dump resulting in this odd output
                if (convertedConfig.other && convertedConfig.other === '{}\n') {
                    convertedConfig.other = '';
                }
                return {
                    type,
                    description,
                    configs: [convertedConfig],
                };
            });
            return transformedTag;
        });
    }
    userConfigsToJson(tags) {
        return tags.map(tag => {
            const transformedTag = tag;
            // configurations is the JS representation of the config yaml,
            // so here we take that JS and convert it into a YAML string.
            // we do so while also flattening "other" into the flat yaml beats expect
            transformedTag.configuration_blocks = (tag.configuration_blocks || []).map(block => {
                const { type, description, configs } = block;
                const activeConfig = configs[0];
                const thisConfig = this.tagConfigs.find((conf) => conf.value === type).config;
                const knownConfigIds = thisConfig
                    .map((config) => config.id)
                    .filter((id) => id !== 'other');
                const picked = this.pickDeep(activeConfig, knownConfigIds);
                const convertedConfig = {
                    ...js_yaml_1.default.safeLoad(activeConfig.other || '{}'),
                    ...picked,
                };
                return {
                    type,
                    description,
                    configs: [this.hydrateTokenizedObject(convertedConfig)],
                };
            });
            return transformedTag;
        });
    }
    /**
     * This function takes an object that contains keys in the pattern of {{keyname}}, and replaces the key with the value of a matching key.
     * Example input:
     * { foo: 'here', '{{foo}}': 'there' }
     * Would return:
     * { foo: 'here', here: 'there' }
     */
    hydrateTokenizedObject(model) {
        return JSON.parse(JSON.stringify(model), (key, value) => {
            return lodash_3.default.isObject(value) && !lodash_3.default.isArray(value)
                ? lodash_3.default.mapKeys(value, (v, k) => {
                    return k.replace(/{{[^{}]+}}/g, (token) => {
                        return model[token.replace(/[{}]+/g, '')];
                    });
                })
                : value;
        });
    }
    /**
     * This function takes an array of strings and object and replaces strings in the array patching the patten of {{key}} with the matching value from the object.
     * Example input:
     * [ '{{key}}', 'other' ], and  { key: 'here', foo: 'there' }
     * Would return:
     * [ 'here', 'other' ]
     */
    hydrateTokenArray(keys, data) {
        return keys.map(key => {
            return key.replace(/{{[^{}]+}}/g, (token) => {
                return data[token.replace(/[{}]+/g, '')];
            });
        });
    }
    pickDeep(obj, keys) {
        const copy = {};
        lodash_3.default.forEach(keys, key => {
            if (lodash_3.default.has(obj, key)) {
                const val = lodash_3.default.get(obj, key);
                lodash_3.default.set(copy, key, val);
            }
        });
        return copy;
    }
}
exports.TagsLib = TagsLib;
