"use strict";
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License;
 * you may not use this file except in compliance with the Elastic License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const constants_1 = require("../../common/constants");
const domain_types_1 = require("../../common/domain_types");
const polyfills_1 = require("../utils/polyfills");
class CMTagsDomain {
    constructor(adapter) {
        this.adapter = adapter;
    }
    async getAll(user, ESQuery) {
        return await this.adapter.getAll(user, ESQuery);
    }
    async getTagsWithIds(user, tagIds) {
        return await this.adapter.getTagsWithIds(user, tagIds);
    }
    async delete(user, tagIds) {
        return await this.adapter.delete(user, tagIds);
    }
    async saveTag(user, tagId, config) {
        const { isValid, message } = await this.validateConfigurationBlocks(config.configuration_blocks);
        if (!isValid) {
            return { isValid, result: message };
        }
        const tag = {
            ...config,
            id: tagId,
            last_updated: new Date(),
        };
        return {
            isValid: true,
            result: await this.adapter.upsertTag(user, tag),
        };
    }
    validateConfigurationBlocks(configurationBlocks) {
        // Get all output types in the array of config blocks
        const outputTypes = configurationBlocks.reduce((typesCollector, block) => {
            if (block.type !== 'output') {
                return typesCollector;
            }
            // get all keys, where the key is the output type with the exception of the output key itself.
            const keys = lodash_1.flatten(block.configs.map((config) => Object.keys(config).filter(key => key !== 'output')));
            typesCollector = [...typesCollector, ...keys];
            return typesCollector;
        }, []);
        // If not a provided output type, fail validation
        if (outputTypes.some((type) => !domain_types_1.OutputTypesArray.includes(type))) {
            return { isValid: false, message: 'Invalid output type' };
        }
        const types = lodash_1.uniq(configurationBlocks.map((block) => block.type));
        // If none of the types in the given configuration blocks are uniqueness-enforcing,
        // we don't need to perform any further validation checks.
        const uniquenessEnforcingTypes = lodash_1.intersection(types, constants_1.UNIQUENESS_ENFORCING_TYPES);
        if (uniquenessEnforcingTypes.length === 0) {
            return { isValid: true };
        }
        // Count the number of uniqueness-enforcing types in the given configuration blocks
        const typeCountMap = configurationBlocks.reduce((map, block) => {
            const { type } = block;
            if (!uniquenessEnforcingTypes.includes(type)) {
                return map;
            }
            const count = map[type] || 0;
            return {
                ...map,
                [type]: count + 1,
            };
        }, {});
        // If there is no more than one of any uniqueness-enforcing types in the given
        // configuration blocks, we don't need to perform any further validation checks.
        if (lodash_1.values(typeCountMap).filter(count => count > 1).length === 0) {
            return { isValid: true };
        }
        const message = polyfills_1.entries(typeCountMap)
            .filter(([, count]) => count > 1)
            .map(([type, count]) => `Expected only one configuration block of type '${type}' but found ${count}`)
            .join(' ');
        return {
            isValid: false,
            message,
        };
    }
}
exports.CMTagsDomain = CMTagsDomain;
