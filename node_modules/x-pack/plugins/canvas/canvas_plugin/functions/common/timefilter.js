'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.timefilter = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /*
                                                                                                                                                                                                                                                                   * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
                                                                                                                                                                                                                                                                   * or more contributor license agreements. Licensed under the Elastic License;
                                                                                                                                                                                                                                                                   * you may not use this file except in compliance with the Elastic License.
                                                                                                                                                                                                                                                                   */

var _datemath = require('@elastic/datemath');

var _datemath2 = _interopRequireDefault(_datemath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var timefilter = exports.timefilter = function timefilter() {
  return {
    name: 'timefilter',
    aliases: [],
    type: 'filter',
    context: {
      types: ['filter']
    },
    help: 'Create a timefilter for querying a source',
    args: {
      column: {
        type: ['string'],
        aliases: ['field', 'c'],
        default: '@timestamp',
        help: 'The column or field to attach the filter to'
      },
      from: {
        types: ['string', 'null'],
        aliases: ['f', 'start'],
        help: 'Beginning of the range, in ISO8601 or Elasticsearch datemath format'
      },
      to: {
        types: ['string', 'null'],
        aliases: ['t', 'end'],
        help: 'End of the range, in ISO8601 or Elasticsearch datemath format'
      }
    },
    fn: function fn(context, args) {
      if (!args.from && !args.to) {
        return context;
      }

      var from = args.from,
          to = args.to,
          column = args.column;

      var filter = {
        type: 'time',
        column: column
      };

      function parseAndValidate(str) {
        if (!str) {
          return;
        }

        var moment = _datemath2.default.parse(str);
        if (!moment || !moment.isValid()) {
          throw new Error('Invalid date/time string: \'' + str + '\'');
        }
        return moment.toISOString();
      }

      if (to != null) {
        filter.to = parseAndValidate(to);
      }

      if (from != null) {
        filter.from = parseAndValidate(from);
      }

      return _extends({}, context, { and: [].concat(_toConsumableArray(context.and), [filter]) });
    }
  };
};