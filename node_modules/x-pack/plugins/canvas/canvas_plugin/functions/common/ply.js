'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ply = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * or more contributor license agreements. Licensed under the Elastic License;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * you may not use this file except in compliance with the Elastic License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

var _lodash = require('lodash');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function combineColumns(arrayOfColumnsArrays) {
  return arrayOfColumnsArrays.reduce(function (resultingColumns, columns) {
    if (columns) {
      columns.forEach(function (column) {
        if (resultingColumns.find(function (resultingColumn) {
          return resultingColumn.name === column.name;
        })) {
          return;
        } else {
          resultingColumns.push(column);
        }
      });
    }

    return resultingColumns;
  }, []);
}

// This handles merging the tables produced by multiple expressions run on a single member of the `by` split.
// Thus all tables must be the same length, although their columns do not need to be the same, we will handle combining the columns
function combineAcross(datatableArray) {
  var _datatableArray = _slicedToArray(datatableArray, 1),
      referenceTable = _datatableArray[0];

  var targetRowLength = referenceTable.rows.length;

  // Sanity check
  datatableArray.forEach(function (datatable) {
    if (datatable.rows.length !== targetRowLength) {
      throw new Error('All expressions must return the same number of rows');
    }
  });

  // Merge columns and rows.
  var arrayOfRowsArrays = (0, _lodash.map)(datatableArray, 'rows');
  var rows = [];
  for (var i = 0; i < targetRowLength; i++) {
    var rowsAcross = (0, _lodash.map)(arrayOfRowsArrays, i);

    // The reason for the Object.assign is that rowsAcross is an array
    // and those rows need to be applied as arguments to Object.assign
    rows.push(Object.assign.apply(Object, [{}].concat(_toConsumableArray(rowsAcross))));
  }

  var columns = combineColumns((0, _lodash.map)(datatableArray, 'columns'));

  return {
    type: 'datatable',
    rows: rows,
    columns: columns
  };
}

var ply = exports.ply = function ply() {
  return {
    name: 'ply',
    type: 'datatable',
    help: 'Subdivide a datatable and pass the resulting tables into an expression, then merge the output',
    context: {
      types: ['datatable']
    },
    args: {
      by: {
        types: ['string'],
        help: 'The column to subdivide on',
        multi: true
      },
      expression: {
        types: ['datatable'],
        resolve: false,
        multi: true,
        aliases: ['fn', 'function'],
        help: 'An expression to pass each resulting data table into. Tips: \n' + ' Expressions must return a datatable. Use `as` to turn literals into datatables.\n' + ' Multiple expressions must return the same number of rows.' + ' If you need to return a differing row count, pipe into another instance of ply.\n' + ' If multiple expressions return the same columns, the last one wins.'
      }
      // In the future it may make sense to add things like shape, or tooltip values, but I think what we have is good for now
      // The way the function below is written you can add as many arbitrary named args as you want.
    },
    fn: function fn(context, args) {
      if (!args) {
        return context;
      }
      var byColumns = void 0;
      var originalDatatables = void 0;

      if (args.by) {
        byColumns = args.by.map(function (by) {
          var column = context.columns.find(function (column) {
            return column.name === by;
          });
          if (!column) {
            throw new Error('Column not found: \'' + by + '\'');
          }
          return column;
        });
        var keyedDatatables = (0, _lodash.groupBy)(context.rows, function (row) {
          return JSON.stringify((0, _lodash.pick)(row, args.by));
        });
        originalDatatables = Object.values(keyedDatatables).map(function (rows) {
          return _extends({}, context, {
            rows: rows
          });
        });
      } else {
        originalDatatables = [context];
      }

      var datatablePromises = originalDatatables.map(function (originalDatatable) {
        var expressionResultPromises = [];

        if (args.expression) {
          expressionResultPromises = args.expression.map(function (expression) {
            return expression(originalDatatable);
          });
        } else {
          expressionResultPromises.push(Promise.resolve(originalDatatable));
        }

        return Promise.all(expressionResultPromises).then(combineAcross);
      });

      return Promise.all(datatablePromises).then(function (newDatatables) {
        // Here we're just merging each for the by splits, so it doesn't actually matter if the rows are the same length
        var columns = combineColumns([byColumns].concat((0, _lodash.map)(newDatatables, 'columns')));
        var rows = (0, _lodash.flatten)(newDatatables.map(function (dt, i) {
          var byColumnValues = (0, _lodash.pick)(originalDatatables[i].rows[0], args.by);
          return dt.rows.map(function (row) {
            return _extends({}, byColumnValues, row);
          });
        }));

        return {
          type: 'datatable',
          rows: rows,
          columns: columns
        };
      });
    }
  };
};