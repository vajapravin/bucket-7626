'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pointseries = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /*
                                                                                                                                                                                                                                                                   * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
                                                                                                                                                                                                                                                                   * or more contributor license agreements. Licensed under the Elastic License;
                                                                                                                                                                                                                                                                   * you may not use this file except in compliance with the Elastic License.
                                                                                                                                                                                                                                                                   */

var _lodash = require('lodash.uniqby');

var _lodash2 = _interopRequireDefault(_lodash);

var _tinymath = require('tinymath');

var _lodash3 = require('lodash');

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _pivot_object_array = require('../../../../../common/lib/pivot_object_array');

var _unquote_string = require('../../../../../common/lib/unquote_string');

var _is_column_reference = require('./lib/is_column_reference');

var _get_expression_type = require('./lib/get_expression_type');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// TODO: pointseries performs poorly, that's why we run it on the server.

var columnExists = function columnExists(cols, colName) {
  return cols.includes((0, _unquote_string.unquoteString)(colName));
};

var pointseries = exports.pointseries = function pointseries() {
  return {
    name: 'pointseries',
    type: 'pointseries',
    help: 'Turn a datatable into a point series model. Currently we differentiate measure from dimensions by looking for a [TinyMath function](https://www.elastic.co/guide/en/kibana/current/canvas-tinymath-functions.html). ' + 'If you enter a TinyMath expression in your argument, we treat that argument as a measure, otherwise it is a dimension. Dimensions are combined to create unique ' + 'keys. Measures are then deduplicated by those keys using the specified TinyMath function',
    context: {
      types: ['datatable']
    },
    args: {
      x: {
        types: ['string', 'null'],
        help: 'The values along the X-axis'
      },
      y: {
        types: ['string', 'null'],
        help: 'The values along the y-axis'
      },
      color: {
        types: ['string', 'null'],
        help: "An expression to use in determining the mark's color" // If you need categorization, transform the field.
      },
      size: {
        types: ['string', 'null'],
        help: 'For elements that support it, the size of the marks'
      },
      text: {
        types: ['string', 'null'],
        help: 'For use in charts that support it, the text to show in the mark'
      }
      // In the future it may make sense to add things like shape, or tooltip values, but I think what we have is good for now
      // The way the function below is written you can add as many arbitrary named args as you want.
    },
    fn: function fn(context, args) {
      // Note: can't replace pivotObjectArray with datatableToMathContext, lose name of non-numeric columns
      var columnNames = context.columns.map(function (col) {
        return col.name;
      });
      var mathScope = (0, _pivot_object_array.pivotObjectArray)(context.rows, columnNames);
      var autoQuoteColumn = function autoQuoteColumn(col) {
        if (!columnNames.includes(col)) {
          return col;
        }
        return col.match(/\s/) ? '\'' + col + '\'' : col;
      };

      var measureNames = [];
      var dimensions = [];
      var columns = {};

      // Separates args into dimensions and measures arrays
      // by checking if arg is a column reference (dimension)
      Object.keys(args).forEach(function (arg) {
        var mathExp = autoQuoteColumn(args[arg]);

        if (mathExp != null && mathExp.trim() !== '') {
          var col = {
            type: '',
            role: '',
            expression: mathExp
          };

          if ((0, _is_column_reference.isColumnReference)(mathExp)) {
            // TODO: Do something better if the column does not exist
            if (!columnExists(columnNames, mathExp)) {
              return;
            }

            dimensions.push({
              name: arg,
              value: mathExp
            });
            col.type = (0, _get_expression_type.getExpressionType)(context.columns, mathExp);
            col.role = 'dimension';
          } else {
            measureNames.push(arg);
            col.type = 'number';
            col.role = 'measure';
          }

          columns[arg] = col;
        }
      });

      var PRIMARY_KEY = '%%CANVAS_POINTSERIES_PRIMARY_KEY%%';
      var rows = context.rows.map(function (row, i) {
        return _extends({}, row, _defineProperty({}, PRIMARY_KEY, i));
      });

      function normalizeValue(expression, value) {
        switch ((0, _get_expression_type.getExpressionType)(context.columns, expression)) {
          case 'string':
            return String(value);
          case 'number':
            return Number(value);
          case 'date':
            return (0, _moment2.default)(value).valueOf();
          default:
            return value;
        }
      }

      // Dimensions
      // Group rows by their dimension values, using the argument values and preserving the PRIMARY_KEY
      // There's probably a better way to do this
      var results = rows.reduce(function (acc, row, i) {
        var newRow = dimensions.reduce(function (acc, _ref) {
          var name = _ref.name,
              value = _ref.value;

          try {
            acc[name] = args[name] ? normalizeValue(value, (0, _tinymath.evaluate)(value, mathScope)[i]) : '_all';
          } catch (e) {
            // TODO: handle invalid column names...
            // Do nothing if column does not exist
            // acc[dimension] = '_all';
          }
          return acc;
        }, _defineProperty({}, PRIMARY_KEY, row[PRIMARY_KEY]));

        return Object.assign(acc, _defineProperty({}, row[PRIMARY_KEY], newRow));
      }, {});

      // Measures
      // First group up all of the distinct dimensioned bits. Each of these will be reduced to just 1 value
      // for each measure
      var measureKeys = (0, _lodash3.groupBy)(rows, function (row) {
        return dimensions.map(function (_ref2) {
          var name = _ref2.name;
          return args[name] ? row[args[name]] : '_all';
        }).join('::%BURLAP%::');
      });

      // Then compute that 1 value for each measure
      (0, _lodash3.values)(measureKeys).forEach(function (rows) {
        var subtable = { type: 'datatable', columns: context.columns, rows: rows };
        var subScope = (0, _pivot_object_array.pivotObjectArray)(subtable.rows, subtable.columns.map(function (col) {
          return col.name;
        }));
        var measureValues = measureNames.map(function (measure) {
          try {
            var ev = (0, _tinymath.evaluate)(args[measure], subScope);
            if (Array.isArray(ev)) {
              throw new Error('Expressions must be wrapped in a function such as sum()');
            }

            return ev;
          } catch (e) {
            // TODO: don't catch if eval to Array
            return null;
          }
        });

        rows.forEach(function (row) {
          Object.assign(results[row[PRIMARY_KEY]], (0, _lodash3.zipObject)(measureNames, measureValues));
        });
      });

      // It only makes sense to uniq the rows in a point series as 2 values can not exist in the exact same place at the same time.
      var resultingRows = (0, _lodash2.default)((0, _lodash3.values)(results).map(function (row) {
        return (0, _lodash3.omit)(row, PRIMARY_KEY);
      }), JSON.stringify);

      return {
        type: 'pointseries',
        columns: columns,
        rows: resultingRows
      };
    }
  };
};