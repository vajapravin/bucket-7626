"use strict";
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License;
 * you may not use this file except in compliance with the Elastic License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const lodash_1 = require("lodash");
const chrome_1 = tslib_1.__importDefault(require("ui/chrome"));
const url_1 = tslib_1.__importDefault(require("url"));
const uuid_1 = tslib_1.__importDefault(require("uuid"));
const constants_1 = require("../../../../../common/constants");
// @ts-ignore
const watcher_1 = require("../../../../services/rest/watcher");
function getSlackPathUrl(slackUrl) {
    if (slackUrl) {
        const { path } = url_1.default.parse(slackUrl);
        return path;
    }
}
async function createErrorGroupWatch({ emails = [], schedule, serviceName, slackUrl, threshold, timeRange }) {
    const id = `apm-${uuid_1.default.v4()}`;
    const apmIndexPatternTitle = chrome_1.default.getInjected('apmIndexPatternTitle');
    const slackUrlPath = getSlackPathUrl(slackUrl);
    const emailTemplate = `Your service "{{ctx.metadata.serviceName}}" has error groups which exceeds {{ctx.metadata.threshold}} occurrences within "{{ctx.metadata.timeRangeValue}}{{ctx.metadata.timeRangeUnit}}"

{{#ctx.payload.aggregations.error_groups.buckets}}
<strong>{{sample.hits.hits.0._source.error.log.message}}{{^sample.hits.hits.0._source.error.log.message}}{{sample.hits.hits.0._source.error.exception.message}}{{/sample.hits.hits.0._source.error.log.message}}</strong>
{{sample.hits.hits.0._source.error.culprit}}{{^sample.hits.hits.0._source.error.culprit}}N/A{{/sample.hits.hits.0._source.error.culprit}}
{{doc_count}} occurrences
{{/ctx.payload.aggregations.error_groups.buckets}}`.replace(/\n/g, '<br/>');
    const slackTemplate = `Your service "{{ctx.metadata.serviceName}}" has error groups which exceeds {{ctx.metadata.threshold}} occurrences within "{{ctx.metadata.timeRangeValue}}{{ctx.metadata.timeRangeUnit}}"
{{#ctx.payload.aggregations.error_groups.buckets}}
>*{{sample.hits.hits.0._source.error.log.message}}{{^sample.hits.hits.0._source.error.log.message}}{{sample.hits.hits.0._source.error.exception.message}}{{/sample.hits.hits.0._source.error.log.message}}*
>{{#sample.hits.hits.0._source.error.culprit}}\`{{sample.hits.hits.0._source.error.culprit}}\`{{/sample.hits.hits.0._source.error.culprit}}{{^sample.hits.hits.0._source.error.culprit}}N/A{{/sample.hits.hits.0._source.error.culprit}}
>{{doc_count}} occurrences
{{/ctx.payload.aggregations.error_groups.buckets}}`;
    const actions = {
        log_error: { logging: { text: emailTemplate } }
    };
    const body = {
        metadata: {
            emails,
            trigger: 'This value must be changed in trigger section',
            serviceName,
            threshold,
            timeRangeValue: timeRange.value,
            timeRangeUnit: timeRange.unit,
            slackUrlPath
        },
        trigger: {
            schedule
        },
        input: {
            search: {
                request: {
                    indices: [apmIndexPatternTitle],
                    body: {
                        size: 0,
                        query: {
                            bool: {
                                filter: [
                                    { term: { [constants_1.SERVICE_NAME]: '{{ctx.metadata.serviceName}}' } },
                                    { term: { [constants_1.PROCESSOR_EVENT]: 'error' } },
                                    {
                                        range: {
                                            '@timestamp': {
                                                gte: 'now-{{ctx.metadata.timeRangeValue}}{{ctx.metadata.timeRangeUnit}}'
                                            }
                                        }
                                    }
                                ]
                            }
                        },
                        aggs: {
                            error_groups: {
                                terms: {
                                    min_doc_count: '{{ctx.metadata.threshold}}',
                                    field: constants_1.ERROR_GROUP_ID,
                                    size: 10,
                                    order: {
                                        _count: 'desc'
                                    }
                                },
                                aggs: {
                                    sample: {
                                        top_hits: {
                                            _source: [
                                                constants_1.ERROR_LOG_MESSAGE,
                                                constants_1.ERROR_EXC_MESSAGE,
                                                constants_1.ERROR_EXC_HANDLED,
                                                constants_1.ERROR_CULPRIT,
                                                constants_1.ERROR_GROUP_ID,
                                                '@timestamp'
                                            ],
                                            sort: [
                                                {
                                                    '@timestamp': 'desc'
                                                }
                                            ],
                                            size: 1
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        condition: {
            script: {
                source: 'return ctx.payload.aggregations.error_groups.buckets.length > 0'
            }
        },
        actions
    };
    if (slackUrlPath) {
        body.actions.slack_webhook = {
            webhook: {
                scheme: 'https',
                host: 'hooks.slack.com',
                port: 443,
                method: 'POST',
                path: '{{ctx.metadata.slackUrlPath}}',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: `__json__::${JSON.stringify({
                    text: slackTemplate
                })}`
            }
        };
    }
    if (!lodash_1.isEmpty(emails)) {
        body.actions.email = {
            email: {
                to: '{{#join}}ctx.metadata.emails{{/join}}',
                subject: `"{{ctx.metadata.serviceName}}" has error groups which exceeds the threshold`,
                body: {
                    html: emailTemplate
                }
            }
        };
    }
    await watcher_1.createWatch(id, body);
    return id;
}
exports.createErrorGroupWatch = createErrorGroupWatch;
