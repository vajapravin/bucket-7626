"use strict";
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License;
 * you may not use this file except in compliance with the Elastic License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const lodash_1 = require("lodash");
const react_1 = tslib_1.__importStar(require("react"));
const EmptyMessage_1 = require("../../shared/EmptyMessage");
const LibraryStackFrames_1 = require("./LibraryStackFrames");
const Stackframe_1 = require("./Stackframe");
function Stacktrace({ stackframes = [], codeLanguage }) {
    if (lodash_1.isEmpty(stackframes)) {
        return react_1.default.createElement(EmptyMessage_1.EmptyMessage, { heading: "No stacktrace available.", hideSubheading: true });
    }
    const groups = getGroupedStackframes(stackframes);
    return (react_1.default.createElement(react_1.Fragment, null, groups.map((group, i) => {
        // library frame
        if (group.isLibraryFrame) {
            const initialVisiblity = groups.length === 1; // if there is only a single group it should be visible initially
            return (react_1.default.createElement(LibraryStackFrames_1.LibraryStackFrames, { key: i, initialVisiblity: initialVisiblity, stackframes: group.stackframes, codeLanguage: codeLanguage }));
        }
        // non-library frame
        return group.stackframes.map((stackframe, idx) => (react_1.default.createElement(Stackframe_1.Stackframe, { key: `${i}-${idx}`, codeLanguage: codeLanguage, stackframe: stackframe })));
    })));
}
exports.Stacktrace = Stacktrace;
function getGroupedStackframes(stackframes) {
    return stackframes.reduce((acc, stackframe) => {
        const prevGroup = lodash_1.last(acc);
        const shouldAppend = prevGroup &&
            prevGroup.isLibraryFrame === stackframe.library_frame &&
            !prevGroup.excludeFromGrouping &&
            !stackframe.exclude_from_grouping;
        // append to group
        if (shouldAppend) {
            prevGroup.stackframes.push(stackframe);
            return acc;
        }
        // create new group
        acc.push({
            isLibraryFrame: Boolean(stackframe.library_frame),
            excludeFromGrouping: Boolean(stackframe.exclude_from_grouping),
            stackframes: [stackframe]
        });
        return acc;
    }, []);
}
exports.getGroupedStackframes = getGroupedStackframes;
