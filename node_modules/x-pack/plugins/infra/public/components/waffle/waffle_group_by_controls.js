"use strict";
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License;
 * you may not use this file except in compliance with the Elastic License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
var _a;
"use strict";
const eui_1 = require("@elastic/eui");
const react_1 = require("@kbn/i18n/react");
const react_2 = tslib_1.__importDefault(require("react"));
const types_1 = require("../../graphql/types");
let OPTIONS;
const getOptions = (nodeType, intl) => {
    if (!OPTIONS) {
        OPTIONS = {
            [types_1.InfraNodeType.pod]: [
                {
                    text: intl.formatMessage({
                        id: 'xpack.infra.waffle.podGroupByOptions.namespaceLabel',
                        defaultMessage: 'Namespace',
                    }),
                    type: types_1.InfraPathType.terms,
                    field: 'kubernetes.namespace',
                },
                {
                    text: intl.formatMessage({
                        id: 'xpack.infra.waffle.podGroupByOptions.nodeLabel',
                        defaultMessage: 'Node',
                    }),
                    type: types_1.InfraPathType.terms,
                    field: 'kubernetes.node.name',
                },
            ],
            [types_1.InfraNodeType.container]: [
                {
                    text: intl.formatMessage({
                        id: 'xpack.infra.waffle.containerGroupByOptions.hostLabel',
                        defaultMessage: 'Host',
                    }),
                    type: types_1.InfraPathType.terms,
                    field: 'host.name',
                },
                {
                    text: intl.formatMessage({
                        id: 'xpack.infra.waffle.containerGroupByOptions.availabilityZoneLabel',
                        defaultMessage: 'Availability Zone',
                    }),
                    type: types_1.InfraPathType.terms,
                    field: 'meta.cloud.availability_zone',
                },
                {
                    text: intl.formatMessage({
                        id: 'xpack.infra.waffle.containerGroupByOptions.machineTypeLabel',
                        defaultMessage: 'Machine Type',
                    }),
                    type: types_1.InfraPathType.terms,
                    field: 'meta.cloud.machine_type',
                },
                {
                    text: intl.formatMessage({
                        id: 'xpack.infra.waffle.containerGroupByOptions.projectIDLabel',
                        defaultMessage: 'Project ID',
                    }),
                    type: types_1.InfraPathType.terms,
                    field: 'meta.cloud.project_id',
                },
                {
                    text: intl.formatMessage({
                        id: 'xpack.infra.waffle.containerGroupByOptions.providerLabel',
                        defaultMessage: 'Provider',
                    }),
                    type: types_1.InfraPathType.terms,
                    field: 'meta.cloud.provider',
                },
            ],
            [types_1.InfraNodeType.host]: [
                {
                    text: intl.formatMessage({
                        id: 'xpack.infra.waffle.hostGroupByOptions.availabilityZoneLabel',
                        defaultMessage: 'Availability Zone',
                    }),
                    type: types_1.InfraPathType.terms,
                    field: 'meta.cloud.availability_zone',
                },
                {
                    text: intl.formatMessage({
                        id: 'xpack.infra.waffle.hostGroupByOptions.machineTypeLabel',
                        defaultMessage: 'Machine Type',
                    }),
                    type: types_1.InfraPathType.terms,
                    field: 'meta.cloud.machine_type',
                },
                {
                    text: intl.formatMessage({
                        id: 'xpack.infra.waffle.hostGroupByOptions.projectIDLabel',
                        defaultMessage: 'Project ID',
                    }),
                    type: types_1.InfraPathType.terms,
                    field: 'meta.cloud.project_id',
                },
                {
                    text: intl.formatMessage({
                        id: 'xpack.infra.waffle.hostGroupByOptions.cloudProviderLabel',
                        defaultMessage: 'Cloud Provider',
                    }),
                    type: types_1.InfraPathType.terms,
                    field: 'meta.cloud.provider',
                },
            ],
        };
    }
    return OPTIONS[nodeType];
};
const initialState = {
    isPopoverOpen: false,
};
exports.WaffleGroupByControls = react_1.injectI18n((_a = class extends react_2.default.PureComponent {
        constructor() {
            super(...arguments);
            this.state = initialState;
            this.handleRemove = (field) => () => {
                const { groupBy } = this.props;
                this.props.onChange(groupBy.filter(g => g.field !== field));
                // We need to close the panel after we rmeove the pill icon otherwise
                // it will remain open because the click is still captured by the EuiFilterButton
                setTimeout(() => this.handleClose());
            };
            this.handleClose = () => {
                this.setState({ isPopoverOpen: false });
            };
            this.handleToggle = () => {
                this.setState(state => ({ isPopoverOpen: !state.isPopoverOpen }));
            };
            this.handleClick = (field) => () => {
                const { groupBy } = this.props;
                if (groupBy.some(g => g.field === field)) {
                    this.handleRemove(field)();
                }
                else if (this.props.groupBy.length < 2) {
                    this.props.onChange([...groupBy, { type: types_1.InfraPathType.terms, field }]);
                    this.handleClose();
                }
            };
        }
        render() {
            const { nodeType, groupBy, intl } = this.props;
            const options = getOptions(nodeType, intl);
            if (!options.length) {
                throw Error(intl.formatMessage({
                    id: 'xpack.infra.waffle.unableToSelectGroupErrorMessage',
                    defaultMessage: 'Unable to select group by options for {nodeType}',
                }, {
                    nodeType,
                }));
            }
            const panels = [
                {
                    id: 'firstPanel',
                    title: intl.formatMessage({
                        id: 'xpack.infra.waffle.selectTwoGroupingsTitle',
                        defaultMessage: 'Select up to two groupings',
                    }),
                    items: options.map(o => {
                        const icon = groupBy.some(g => g.field === o.field) ? 'check' : 'empty';
                        const panel = { name: o.text, onClick: this.handleClick(o.field), icon };
                        return panel;
                    }),
                },
            ];
            const buttonBody = groupBy.length > 0 ? (groupBy
                .map(g => options.find(o => o.field === g.field))
                .filter(o => o != null)
                // In this map the `o && o.field` is totally unnecessary but Typescript is
                // too stupid to realize that the filter above prevents the next map from being null
                .map(o => (react_2.default.createElement(eui_1.EuiBadge, { key: o && o.field, iconType: "cross", iconOnClick: this.handleRemove((o && o.field) || ''), iconOnClickAriaLabel: intl.formatMessage({
                    id: 'xpack.infra.waffle.removeGroupingItemAriaLabel',
                    defaultMessage: 'Remove {groupingItem} grouping',
                }, {
                    groupingItem: o && o.text,
                }) }, o && o.text)))) : (react_2.default.createElement(react_1.FormattedMessage, { id: "xpack.infra.waffle.groupByAllTitle", defaultMessage: "All" }));
            const button = (react_2.default.createElement(eui_1.EuiFilterButton, { iconType: "arrowDown", onClick: this.handleToggle },
                react_2.default.createElement(react_1.FormattedMessage, { id: "xpack.infra.waffle.groupByButtonLabel", defaultMessage: "Group By: " }),
                buttonBody));
            return (react_2.default.createElement(eui_1.EuiFilterGroup, null,
                react_2.default.createElement(eui_1.EuiPopover, { isOpen: this.state.isPopoverOpen, id: "groupByPanel", button: button, panelPaddingSize: "none", closePopover: this.handleClose },
                    react_2.default.createElement(eui_1.EuiContextMenu, { initialPanelId: "firstPanel", panels: panels }))));
        }
    },
    _a.displayName = 'WaffleGroupByControls',
    _a));
