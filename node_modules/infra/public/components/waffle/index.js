"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
var _a;
"use strict";
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License;
 * you may not use this file except in compliance with the Elastic License.
 */
const eui_1 = require("@elastic/eui");
const react_1 = require("@kbn/i18n/react");
const lodash_1 = require("lodash");
const react_2 = tslib_1.__importDefault(require("react"));
const styled_components_1 = tslib_1.__importDefault(require("styled-components"));
const type_guards_1 = require("../../containers/waffle/type_guards");
const types_1 = require("../../graphql/types");
const lib_1 = require("../../lib/lib");
const formatters_1 = require("../../utils/formatters");
const auto_sizer_1 = require("../auto_sizer");
const loading_1 = require("../loading");
const group_of_groups_1 = require("./group_of_groups");
const group_of_nodes_1 = require("./group_of_nodes");
const legend_1 = require("./legend");
const apply_wafflemap_layout_1 = require("./lib/apply_wafflemap_layout");
const METRIC_FORMATTERS = {
    [types_1.InfraMetricType.count]: { formatter: lib_1.InfraFormatterType.number, template: '{{value}}' },
    [types_1.InfraMetricType.cpu]: {
        formatter: lib_1.InfraFormatterType.percent,
        template: '{{value}}',
        bounds: { min: 0, max: 1 },
    },
    [types_1.InfraMetricType.memory]: {
        formatter: lib_1.InfraFormatterType.percent,
        template: '{{value}}',
        bounds: { min: 0, max: 1 },
    },
    [types_1.InfraMetricType.rx]: { formatter: lib_1.InfraFormatterType.bits, template: '{{value}}/s' },
    [types_1.InfraMetricType.tx]: { formatter: lib_1.InfraFormatterType.bits, template: '{{value}}/s' },
    [types_1.InfraMetricType.logRate]: {
        formatter: lib_1.InfraFormatterType.abbreviatedNumber,
        template: '{{value}}/s',
    },
};
const extractValuesFromMap = (groups, values = []) => {
    return groups.reduce((acc, group) => {
        if (type_guards_1.isWaffleMapGroupWithGroups(group)) {
            return acc.concat(extractValuesFromMap(group.groups, values));
        }
        if (type_guards_1.isWaffleMapGroupWithNodes(group)) {
            return acc.concat(group.nodes.map(node => {
                return node.metric.value || 0;
            }));
        }
        return acc;
    }, values);
};
const calculateBoundsFromMap = (map) => {
    const values = extractValuesFromMap(map);
    // if there is only one value then we need to set the bottom range to zero
    if (values.length === 1) {
        values.unshift(0);
    }
    return { min: lodash_1.min(values), max: lodash_1.max(values) };
};
exports.Waffle = react_1.injectI18n((_a = class extends react_2.default.Component {
        constructor() {
            super(...arguments);
            // TODO: Change this to a real implimentation using the tickFormatter from the prototype as an example.
            this.formatter = (val) => {
                const { metric } = this.props.options;
                const metricFormatter = lodash_1.get(METRIC_FORMATTERS, metric.type, METRIC_FORMATTERS[types_1.InfraMetricType.count]);
                if (val == null) {
                    return '';
                }
                const formatter = formatters_1.createFormatter(metricFormatter.formatter, metricFormatter.template);
                return formatter(val);
            };
            this.handleDrilldown = (filter) => {
                this.props.onDrilldown({
                    kind: 'kuery',
                    expression: filter,
                });
                return;
            };
            this.renderGroup = (bounds, timeRange) => (group) => {
                if (type_guards_1.isWaffleMapGroupWithGroups(group)) {
                    return (react_2.default.createElement(group_of_groups_1.GroupOfGroups, { onDrilldown: this.handleDrilldown, key: group.id, options: this.props.options, group: group, formatter: this.formatter, bounds: bounds, nodeType: this.props.nodeType, timeRange: timeRange }));
                }
                if (type_guards_1.isWaffleMapGroupWithNodes(group)) {
                    return (react_2.default.createElement(group_of_nodes_1.GroupOfNodes, { key: group.id, options: this.props.options, group: group, onDrilldown: this.handleDrilldown, formatter: this.formatter, isChild: false, bounds: bounds, nodeType: this.props.nodeType, timeRange: timeRange }));
                }
            };
        }
        render() {
            const { loading, map, reload, timeRange, intl } = this.props;
            if (loading) {
                return (react_2.default.createElement(loading_1.InfraLoadingPanel, { height: "100%", width: "100%", text: intl.formatMessage({
                        id: 'xpack.infra.waffle.loadingDataText',
                        defaultMessage: 'Loading data',
                    }) }));
            }
            else if (!loading && map && map.length === 0) {
                return (react_2.default.createElement(CenteredEmptyPrompt, { title: react_2.default.createElement("h2", null,
                        react_2.default.createElement(react_1.FormattedMessage, { id: "xpack.infra.waffle.noDataTitle", defaultMessage: "There is no data to display." })), titleSize: "m", body: react_2.default.createElement("p", null,
                        react_2.default.createElement(react_1.FormattedMessage, { id: "xpack.infra.waffle.noDataDescription", defaultMessage: "Try adjusting your time or filter." })), actions: react_2.default.createElement(eui_1.EuiButton, { iconType: "refresh", color: "primary", fill: true, onClick: () => {
                            reload();
                        } },
                        react_2.default.createElement(react_1.FormattedMessage, { id: "xpack.infra.waffle.checkNewDataButtonLabel", defaultMessage: "Check for new data" })), "data-test-subj": "noMetricsDataPrompt" }));
            }
            const { metric } = this.props.options;
            const metricFormatter = lodash_1.get(METRIC_FORMATTERS, metric.type, METRIC_FORMATTERS[types_1.InfraMetricType.count]);
            const bounds = (metricFormatter && metricFormatter.bounds) || calculateBoundsFromMap(map);
            return (react_2.default.createElement(auto_sizer_1.AutoSizer, { content: true }, ({ measureRef, content: { width = 0, height = 0 } }) => {
                const groupsWithLayout = apply_wafflemap_layout_1.applyWaffleMapLayout(map, width, height);
                return (react_2.default.createElement(WaffleMapOuterContiner, { innerRef: (el) => measureRef(el), "data-test-subj": "waffleMap" },
                    react_2.default.createElement(WaffleMapInnerContainer, null, groupsWithLayout.map(this.renderGroup(bounds, timeRange))),
                    react_2.default.createElement(legend_1.Legend, { formatter: this.formatter, bounds: bounds, legend: this.props.options.legend })));
            }));
        }
    },
    _a.displayName = 'Waffle',
    _a));
const WaffleMapOuterContiner = styled_components_1.default.div `
  flex: 1 0 0%;
  display: flex;
  justify-content: center;
  flex-direction: column;
  overflow-x: hidden;
  overflow-y: auto;
`;
const WaffleMapInnerContainer = styled_components_1.default.div `
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: center;
  align-content: flex-start;
  padding: 10px;
`;
const CenteredEmptyPrompt = styled_components_1.default(eui_1.EuiEmptyPrompt) `
  align-self: center;
`;
